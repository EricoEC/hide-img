<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="shortcut icon" type="image/x-icon" href="assets/images/favicon.svg" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>小番茄格式 图片混淆</title>
<style>
.normal_button{
	min-width: 3.5rem;
    height: 2rem;
    line-height: 2rem;
    font-size: 1rem;
    padding:0 0.5rem;
    margin:0 0.3rem;
	border:0;
    border-radius:6px;
	display: inline-block;
    position: relative;
    vertical-align: middle;
}
.ipt_btn{
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    opacity: 0;
    background-color: #ccc;
}
/* 密码区域样式（保留旧版有效样式） */
.password-area{
    margin: 1rem 0;
    font-size: 1rem;
}
.password-area input{
    height: 1.8rem;
    padding: 0 0.5rem;
    margin: 0 0.3rem;
    width: 120px;
}
</style>
</head>
<body>
<div style="text-align: center;">
<h1>小番茄格式 图片混淆</h1>
<div style="display: inline-block; max-width: 400px;">基于空间填充曲线的新一代图片混淆。混淆算法保持像素的空间相关性，混淆图被压缩仍能保持色彩。仅供技术交流使用。此程序生成的图片格式为jpeg，质量1。</div>
<div>&ZeroWidthSpace;</div>

<!-- 第一步：先放功能按钮（上移，符合要求） -->
<div><span class="normal_button" style="background-color: #180161;color:#fff;">选择图片<input type="file" accept="image/*" id="ipt" class="ipt_btn" /></span><button id="enc" class="normal_button" style="background-color: #4f1787;color:#fff;">混淆</button><button id="dec" class="normal_button" style="background-color: #eb3678;color:#fff;">解混淆</button><button id="re" class="normal_button" style="background-color: #fb773c;color:#fff;">还原</button><button id="download" class="normal_button" style="background-color: #3c8bfb;color:#fff;">下载</button></div>
<div>&ZeroWidthSpace;</div>

<!-- 第二步：再放密码区域（下移，不改变旧版逻辑） -->
<div class="password-area">
    <input type="checkbox" id="usePassword"> 启用密码
    <input type="number" id="passwordInput" placeholder="输入6位数字密码" min="100000" max="999999" disabled>
</div>

<div><img id="display-img" style="max-width: calc(100vw - 32px); max-height: calc(100vh - 32px); display: none;" /></div>
</div>
<script>
function gilbert2d(width, height) {
    const coordinates = [];
    if (width >= height) {
        generate2d(0, 0, width, 0, 0, height, coordinates);
    } else {
        generate2d(0, 0, 0, height, width, 0, coordinates);
    }
    return coordinates;
}
function generate2d(x, y, ax, ay, bx, by, coordinates) {
    const w = Math.abs(ax + ay);
    const h = Math.abs(bx + by);
    const dax = Math.sign(ax), day = Math.sign(ay);
    const dbx = Math.sign(bx), dby = Math.sign(by);
    if (h === 1) {
        for (let i = 0; i < w; i++) {
            coordinates.push([x, y]);
            x += dax;
            y += day;
        }
        return;
    }
    if (w === 1) {
        for (let i = 0; i < h; i++) {
            coordinates.push([x, y]);
            x += dbx;
            y += dby;
        }
        return;
    }
    let ax2 = Math.floor(ax / 2), ay2 = Math.floor(ay / 2);
    let bx2 = Math.floor(bx / 2), by2 = Math.floor(by / 2);
    const w2 = Math.abs(ax2 + ay2);
    const h2 = Math.abs(bx2 + by2);
    if (2 * w > 3 * h) {
        if ((w2 % 2) && (w > 2)) {
            ax2 += dax;
            ay2 += day;
        }
        generate2d(x, y, ax2, ay2, bx, by, coordinates);
        generate2d(x + ax2, y + ay2, ax - ax2, ay - ay2, bx, by, coordinates);
    } else {
        if ((h2 % 2) && (h > 2)) {
            bx2 += dbx;
            by2 += dby;
        }
        generate2d(x, y, bx2, by2, ax2, ay2, coordinates);
        generate2d(x + bx2, y + by2, ax, ay, bx - bx2, by - by2, coordinates);
        generate2d(x + (ax - dax) + (bx2 - dbx), y + (ay - day) + (by2 - dby),
            -bx2, -by2, -(ax - ax2), -(ay - ay2), coordinates);
    }
}
</script>
<script>
const img = document.getElementById("display-img")
const usePassword = document.getElementById("usePassword");
const passwordInput = document.getElementById("passwordInput");

// 密码勾选框逻辑（完全保留旧版有效代码）
usePassword.addEventListener('change', () => {
    passwordInput.disabled = !usePassword.checked;
    if (!usePassword.checked) passwordInput.value = '';
});

function setsrc(src){
    URL.revokeObjectURL(img.src)
    img.src = src
    img.style.display = "inline-block"
}

// 偏移量计算（旧版有效逻辑，未做任何修改）
function getOffset(width, height) {
    if (usePassword.checked && passwordInput.value) {
        const pwd = parseInt(passwordInput.value);
        const totalPixels = width * height;
        return pwd % totalPixels;
    } else {
        return Math.round((Math.sqrt(5) - 1) / 2 * width * height);
    }
}

// 混淆函数（完全保留旧版）
function encrypt(img){
    const cvs = document.createElement("canvas")
    const width = cvs.width = img.width
    const height = cvs.height = img.height
    const ctx = cvs.getContext("2d")
    ctx.drawImage(img, 0, 0)
    const imgdata = ctx.getImageData(0, 0, width, height)
    const imgdata2 = new ImageData(width, height)
    const curve = gilbert2d(width, height)
    const offset = getOffset(width, height);
    for(let i = 0; i < width * height; i++){
        const old_pos = curve[i]
        const new_pos = curve[(i + offset) % (width * height)]
        const old_p = 4 * (old_pos[0] + old_pos[1] * width)
        const new_p = 4 * (new_pos[0] + new_pos[1] * width)
        imgdata2.data.set(imgdata.data.slice(old_p, old_p + 4), new_p)
    }
    ctx.putImageData(imgdata2, 0, 0)
    cvs.toBlob(b => {
        setsrc(URL.createObjectURL(b))
    }, "image/jpeg", 1)
}

// 解混淆函数（完全保留旧版）
function decrypt(img){
    const cvs = document.createElement("canvas")
    const width = cvs.width = img.width
    const height = cvs.height = img.height
    const ctx = cvs.getContext("2d")
    ctx.drawImage(img, 0, 0)
    const imgdata = ctx.getImageData(0, 0, width, height)
    const imgdata2 = new ImageData(width, height)
    const curve = gilbert2d(width, height)
    const offset = getOffset(width, height);
    for(let i = 0; i < width * height; i++){
        const old_pos = curve[i]
        const new_pos = curve[(i + offset) % (width * height)]
        const old_p = 4 * (old_pos[0] + old_pos[1] * width)
        const new_p = 4 * (new_pos[0] + new_pos[1] * width)
        imgdata2.data.set(imgdata.data.slice(new_p, new_p + 4), old_p)
    }
    ctx.putImageData(imgdata2, 0, 0)
    cvs.toBlob(b => {
        setsrc(URL.createObjectURL(b))
    }, "image/jpeg", 1)
}

// 所有按钮逻辑（完全保留旧版有效代码）
const ipt = document.getElementById("ipt")
ipt.onchange = () => {
    if(ipt.files.length > 0){
        setsrc(URL.createObjectURL(ipt.files[0]))
    }
}
const btn_enc = document.getElementById("enc")
btn_enc.onclick = () => {
    if(img.src){
        img.style.display = "none"
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                encrypt(img)
            })
        })
    }
}
const btn_dec = document.getElementById("dec")
btn_dec.onclick = () => {
    if(img.src){
        img.style.display = "none"
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                decrypt(img)
            })
        })
    }
}
const btn_restore = document.getElementById("re")
btn_restore.onclick = () => {
    if(ipt.files.length > 0){
        setsrc(URL.createObjectURL(ipt.files[0]))
    }
}
const btn_download = document.getElementById("download")
btn_download.onclick = () => {
    if(img.src && img.style.display !== "none"){
        const a = document.createElement('a')
        a.href = img.src
        a.download = 'processed_image.jpg'
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
    }
}
</script>
</body>
</html>
